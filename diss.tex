% The master copy of this demo dissertation is held on Dr. Martin Richards filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last Updated by Dorian Peake in 2014

\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{todonotes}  % todo notes
\usepackage{cite}
\usepackage{listings}   % Code listings
\usepackage{color}

% set default language to OCaml
\lstset{language=[Objective]Caml,
        basicstyle=\scriptsize,
        keywordstyle=\color{blue}
}

%\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Dorian Peake}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Parallelism in OCaml Under the JVM} \\
\vspace*{5mm}
Computer Science Tripos \\
\vspace*{5mm}
St John's College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Dorian Peake  \\
College:            & \bf St John's College                     \\
Project Title:      & \bf Parallelism under OCaml using the JVM  \\
Examination:        & \bf Computer Science Tripos, July 2014        \\
Word Count:         & \bf TBC  \\
Project Originator: & Dorian Peake                    \\
Supervisor:         & Jeremy Yallop                   \\ 
\end{tabular}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The aim of this project was to highlight the differences between single and multithreaded OCaml code. This was done by adapting the Lightweight Threading Library (LWT) -- a very popular threading library for OCaml -- to use the OCaml
to Java bytecode compiler OCaml-Java, thus allowing software written with LWT to utilise the multithreading capabilities of the JVM. \todo{fill this out a bit more, maybe talk about what differences the project was looking for/found}

\section*{Work Completed}
{\bf Pinkbook says at most 100 words summarising work completed, e.g. scheduler of LWT to OCaml-Java threads, worker public/private queue structure, benchmarks, etc.}
The LWT threading capabilities have been integrated with OCaml-Java, thus allowing some LWT programs to compile to Java bytecode and run in parallel on the JVM. This is done using a scheduler algorithm which maps LWT threads to
Java threads. \todo{fill this out some more as well when possible}

\section*{Special Difficulties}
{\bf Pinkbook says at most 100 words describing special difficulties, but most should just say "None" }
None, {\em possibly}.

\newpage
\section*{Declaration}

I, Dorian Peake of St John's College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}
\todo{add thanks at the end}
This document owes much to an earlier version written by Simon Moore
.  His help, encouragement and advice was greatly 
appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}
\label{chap:Introduction}
\section{Motivation}
\label{sec:motivation}
% What I want to say:
% Talk about how things are moving/have moved from uniprocessor to multiprocessor systems and parallelism. Important to write programs that will run well on the hardware of the day (which means writing programs which exploit
% prarallelism well) and hopefelly will scale easily to hardware of tomorrow.
% Talk about functional programming, what it is, where it came from and why it's good/cool. Examples of C++11 and Java incoroperating functional paradigms, more and more programmers using functional paradigms for type safety(due to
% static typing) efficiency (due to expressiveness of code, first class functions, etc) and abstraction from the complexity of the hardware. Programs written with ML  cannot crash. Mention map-reduce and maybe some other notable
% examlles..
% Security in the mathematics of how it works.
% Talk (more) on OCaml, how it is a 'very good' functional programming language: based on ML, has all the wonderful things I've mentioned about funcitonal programming implemented in the language, incorperates OOP and imerative when
% neccessary but doesn't allow parallelism due to core runtime and non-concurrent garbage collector.
% Enter OCaml-Java, OCaml to java compiler which allows OCaml code to run on the JVM. Also ultimately means that the compiled code can use multiple java threads - now we have truly parallel OCaml code.
% Although OCaml is singlethreaded at the lowest level, there exist threading libraries to perform asynchronous tasks within OCaml, for example Async (developed by Jane Street \citeme} and LWT, produced by Ocsigen). These libraries
% provide a great interface for multithreading in OCaml but lack the underlying support from the OCaml language - It would be interesting to find out just what the benefits and drawbacks exist from executing OCaml asynchrnous code in
% a multithreaded environment (thus the motivation of the project, we can achieve some sort of comparisson between multithreaded and singlethreaded OCaml using OCaml-Java as our vector into multithreaded OCaml code -- Just a matter
% getting one of the asynchronous libraries to work with OCaml-Java.
% How much better is multithreaded OCaml code over singlethreaded code? What are the challenges/benefits of writing multithreaded programs using a functional programming language? How well do threaded/asynchronous OCaml programs
% translate onto a multithreaded system? It would be interesting to test all these things. (possibly only talk about `I wanted to test the difference between using threaded
%
%
% Talk about why multithreading is important
%
\todo{this para is sounds like a history talk which is what thingybob told us not to do}
Trends current trends in chip advancement have shown that since around 2003\cite{hennessy2012}, the growth in processor frequency has effectively plateaued and computer architects have had to look for different methods of achieving
greater computational power. The diminishing returns of processor frequency have been greatly effected by the amount of energy required to switch a transistor's output -- known as the {\em dynamic energy}. This dynamic energy needs to
be dissapated through the side of the chip die at a size of around 1.5cm. Clearly this becomes an increasingly difficult task for processors with greater clock frequencies which generate more heat energy to dissipate. As a result of
this and some other unmentioned factors, the focus of achieving greater performance has moved from clock frequency improvements to parallel processing. Therefore it is important for software developers to create software that is
able to take full advantage of the hardware of today and estimate ways to make it scale on the hardware of tomorrow.
\\
\\
%
% Talk about why functional programming is important
%
Functional Programming concepts have been around since Turing and Church's work in the 1930's\cite{scott2009} but have become more popular in recent times. The expressiveness that functional programming paradigms give the programmer
has finally caught on in mainstream development and as such languages such as C++ and Java are incorperating notable functional programming techniques such as type inference\cite{web:autokeyword} and first-class anonymous functions
(lambas)\cite{web:javalambda}. Notable functional languages include Haskell and ML which have inspired more widely used functional languages such as OCaml\cite{madhavapeddy2013}. OCaml is a very extensive functional language which
also includes an elegant object system, thus incorperating the best of both functional and imperative programming techniques and making it a very powerful language to develop with. Unfortunately OCaml in it's current vanilla state is
unable to compile parallel code, which is becoming an ever more neccessary approach to development as systems become more and more parallel.
\\
\\
%
% Talk about how java has multithreading but no functional, whereas OCaml is functional with no multithreading
%
Java on the other hand is a very good imperative programming language/system. It compiles to bytecode which runs on it's virtual machine which is implemented in everything from ATM's and credit card Chips\todo{cite where it says ATM's
and credit card chips use Java} to home desktops and servers -- leading to one of the slogan's \todo{find where this slogan is written} `{\em write once, run everywhere}'. Over the years the JVM has become highly optimised to the
hardware/systems that it runs on such that there is little diffrence between Java code running on the JVM and natively compiled code. Furthermore, Java supports parallel processing, fully utilising any number of cores/hardware threads
that the system has to offer.
\\
\\
%
% Talk about how OCaml-Java merges the two but is in need of a sufficient threading library, many exist (LWT, Async) but are not yet compatible. This is where my project comes in.
%
A peice of software called OCaml-Java aims to merge best aspects of both languages together to create a better OCaml programming solution. It achieves this by compiling OCaml code to Java bytecode, thus allowing it to run on any JVM.
This means two things:
\begin{itemize}
\item OCaml can now be written to run on a wide variety of hardware/systems.
\item OCaml can use Java's multithreading capabilities to run fully parallel OCaml code\cite{clerc2012}
\end{itemize}
OCaml-Java comes with a basic collection of concurrency tools which are essentially a small subset of Java's own concurrency library, with wrappers which allows access to them from within OCaml. Clearly the concurrency techniques
provided by Java do not nicely translate to the way concurrency is done in a functional programming language like OCaml. There already exist extremely good and highly optimised OCaml concurrency libraries such as Async by Jane Street
and LWT (Lightweight Threads Library) by Ocsigen, however these will not directly work with OCaml-Java when compiled to Java bytecode. Somehow getting one of these OCaml concurrency libraries working with OCaml-Java would demonstrate
OCaml-Java's true potential for parallel OCaml code, written in the functional flavour that works best with the OCaml language -- this is the motivation for my project.
\\
\\
%
% Briefly outline project, and where I this dissertation will take the reader on their journey
%
My project aims to interface OCaml-Java and the LWT concurrency library in order to demonstrate OCaml-Java's potential for parallelised OCaml code. The rest of this document outlines the preparation and research I conducted in order
to plan my approach to this project in chapter~\ref{chap:preparation}; the methods and processes that were used to implement the project in chapter~\ref{chap:implementation} and the result of the project development and the work
process as a whole in chapter~\ref{chap:evaluation}. My code can also be found in chapter~\ref{chap:appendices}.
\\
\\
%
% Cant think of any related work off the top of my head... Might delete this little section
%
\section{Related Work}
\label{sec:related_work}


% \todo{I don't like the jump between these two paragraphs, seems illogical but they're connected later on}
% Part of the way Programming languages are advancing is towards Functional Programming. Functional Programming concepts have been around since Turing, Church's and Kleene's independent work in the 1930's\cite{scott2009} and
% fundamentally defines the output of a program as the mathematical funcion of its inputs. This is different from imperative languages in that the functions defined in a (purely) functional language have no state and therefore have no
% side effects. If you were to provide the same inputs to the same function you would always get the same output. Another important aspect of functional languages is the idea of functions being first-class values and higher-order
% functions. First-class value functions are functions that are able to be passed as an argument to another function. The function receiving the first-class function argument is known as a higher-order function (which may also return a
% function as a result). Considering these new weapons for development we have obtained from functional programming languages, the expressiveness of our programs has already become incredibly vast. \todo{Might add map function as
% example of higher-order function}.
% Functions such as map, reduce and fold ere very easily expressed using higher-order functions. Java achieves something similar to a higher-order function when using Java Collections, for example Java.util.TreeSet. This class can be
% constructed by passing an object implementing the Comparator interface. This interface contains only one function `compareTo' which creates an ordering between any two elements of a class. Essentially, java is wrapping a class around
% this compareTo function so that it may be passed similarly to a higher-order function. In C you can also pass functions via a function pointer implememnts some aspects of higher-order functions. However bothe Java and C++ are picking
% up many more functional programming paradigms in the latest versions of their languages: Java 8 and C++11\cite{web:javalambda}\cite{web:autokeyword}. Functional programming paradigms are more efficient, with examples such as
% higher-order functions, and safer; many functional languages are almost entirely statically typed which means \todo{no runtime errors, but I'm not sure if thats entirely due to static typing}no runtime errors due to type conflicts and
% faster code (since types do not need to be checked at runtime). The functional programming language ML has become increasingly popular in research institutes and is a great example of a good functional programming
% language. As an example of saftey in functional programming, compiled ML code cannot crash\cite{paulson1996}.


\chapter{Preparation}
\label{chap:preparation}
% Researched into why OCaml cannot fundmentally produce multithreaded code.
% The OCaml-Java paper has a nice section on the reasons that OCaml is not a multithread capable language: Garbage collector is neither parallel nor concurrent and core libraries are not reentrant.
% Ultimately the core libraries can be made reentrant, however sorting out the garbage collector is a more difficult and involved task.
% OCaml does provide a threads library but manual states the threads library is implemented by time sharing on single processor {cite ocaml manual}. 
% Researched into ways of doing concurrent processing in OCaml.
% in conjunction with the OCaml threads library, there are also other threading libraries with a richer feature set, expanding on the OCaml threads library, such as LWT, ASync.
% ultimately the as to which one was solely based on the fact that LWT is more popular, (as I have never worked with either and wouldn't have time to test both of them out and decide which I would like to work with the most).
% Projects exist (such as those given in OCaml-Java paper) on multicore implementations of ocaml
% Research into LWT
% Lwt is an extensive concurrency suite for OCaml which uses lightweight threads that are created and destroyed very quickly.
% almost all expressions used within LWT results in a thread being created, which returns the answer.
% clearly Java threads and LWT threads are not directly compatible (theres a lot of overhead from creating a Java thread compared to an LWT thread), need some sort of scheduler from LWT threads to Java threads
% describe how LWT works:
%   Lwt.Poll repeatedly checks whether a thread has completed, this is used with Lwt_main.run to start a thread off and relay it's completion to the thread that spawned it.
%   As threads are run, more threads are spawned and put onto the end of a thread queue. In single threaded LWT all the threads are executed in FIFO order (drawing time, draw a thread being taken off, spawning more threads onto the
%   back and then executing the next one on the top of the queue)
% Research into OCaml-Java
% Ocaml-Java provides a `Concurrent' module which provides a few core concurrency solutions e.g. locks, condition variables, atomic variables, etc.
% Also provides a threadign library which allows the creation of Java threads to run bytecode compiled OCaml functions.
% all accessible via OCaml therefore little/no Java will/was needed to link this with LWT. Need to essentially map the functions which are executed in OCaml threads to java threads.
% LWT Threads are lightweight and inexpensive to create/destroy, Java threads are expensive to create/destroy therefore won't be good enough to map each LWT thread to each Java thread.
% Leads to requirements: Maximum java thread lifetime (for efficiency, else parallelism could be drowned out by overheads), and some others...
% Tools used:
% The development of this project relies on the OCaml language, LWT and OCaml-Java
% Used github for backup and version control
% also stored code on dropbox for backup purposes and ease of access

%
% Outline of what is to come in this chapter
%
The following chapter outlines the processes taken in preparation for the project's implementation. I begin with a look into OCaml's multithreaded capabilities, including the limitations on developing parallel code and why these
limitations exist. I also discuss LWT's own asynchronous library in comparisson to Java's and the difficulties that may occur when attempting to interface the two. OCaml-Java is overviewed, including what tools become available with
it's use and how it manages to provide the user with concurrency when writing parallel OCaml code. Finally the research is concluded with a set of requirements which I believe are representative of what the project should hope to
achieve and the tools/software I will be using throught it's development.

\section{Investigating Multithreaded OCaml}
\label{sec:investigating_multithreaded_ocaml}
%
% Talk about what makes it impossible to run parallel OCaml code and why OCaml-Java can
%
In order to outline the best implementation plan for the LWT--OCaml-Java interface, it was neccessary to understand the limitations that OCaml possessed in compiling parallel code. The OCaml-Java paper from the 2012 `Trends in
Functional Programming' collection\cite{clerc2012} gives rise to the reason -- stating that the Core OCaml library is not reentant and the OCaml garbage collector is neither parallel nor concurrent. Making the Core library reentrant
is a relatively straight forward change to the system, however making the garbage collector parallel is not as simple. Ultimately there are many ways to perform concurrent and parallel garbage collection, however this has proven to be
`too complex' for the current state of the OCaml system\todo{cite this, definitely saw this somewhere}. Java's G1 is fully parallel\todo{cite me} and allows multithreaded support of Java applications, therefore by compiling OCaml code
do java bytecode, the language may utilise Java's parallelism capabilities.
\\
\\
%
% Talk about ways of doing concurrent processing in OCaml
%
It was neccessary to decide which of the popular concurrency libraries available to OCaml I should use for the purposes of this project therefore I researched into OCaml's ability to produce concurrent OCaml code, which lead me to
OCaml's own inbuilt threads libarary. The OCaml manual\cite{leroy2013} describes the OCaml threads as being concurrently on a single processor using
time sharing. However there exist other concurrency libraries which boast a richer feature set than the one provided by OCaml as default. Examples of these languages are Async -- developed by Jane Street Capital\todo{cite me} -- and LWT
(Lightweight threads library) -- developed by Ocsigen\todo{cite me also}. These are the two main concurrency packages used within OCaml development, choosing one to use within my project was simply a matter of popularity, my reasoning
is that they are both extremely good packages and would serve well to demonstrate the capabilities of multithreaded OCaml-Java.
\\
\\
\section{Investigating LWT}
\label{sec:investigating_lwt}
%
% Research into LWT, how it works and how it should work in relation to OCaml-Java (i.e. scheduling LWT threads since they're teenie weenie)
%
LWT is an extensive concurrency suite for OCaml which is based around the idea of lightweight cooperative threads\cite{dimino2012} where cooperative threads manage their own lifecycle as opposed to preemtive threads which are
controlled externally, e.g. by the operating system. Creating and destroying a thread in LWT are very cheap operations such that the system will create a thread for every system call that is executed. This idea of lightweight threads
with a small lifetime handles itself well to the way OCaml (and languages within the ML family) work which is allocating new data frequently which have a small lifetime. The OCaml garbage collector is also optimised for this by using
generational garbage collection techniques to more frequently collect younger data, as data that has survived a garbage collection once or more before is likely to have an extended lifetime.\cite{chailloux2000}

On the other hand, Java threads have a greater creation overhead and as such cannot be used in a similar fashion to the way LWT threads work without detrimental effects to performance. Java's java.util.concurrent implementations avoid
the creation overheads by utilising thread pools\cite{web:threadpools}. This observation lead me to the implementation decision of creating a thread scheduler which maps LWT threads to Java threads as clearly a 1:1 mapping would
simply expose great amounts of thread creation overhead, possibly crippling any speedup gains would obtain.
\\
\\
%
% Give some examples of LWT code, how it works, how threads are spawned, joined and bound, the thread queue and how it makes things asynchronous
%
There are many functions within LWT to create threads which have various different effects. One of the most commonly used is the {\em bind} function, with the following type:
\\
\begin{lstlisting}[frame=single]
val bind : 'a t -> ('a -> 'b t) -> 'b t
\end{lstlisting}
\hfill\\
Essentially the bind function takes a thread of generic type, a function which takes the return value of the thread, performs some processing returns a new thread. This processing connects the passed thread and function such that when
the thread has finished executing, the function will be run with the return value from the thread. This acts synonymously to the classic `sync' operation within various writings on parallel processing\cite{cormen2009}. The new thread
returned by the bind function is the result of the whole bind operation -- that is, once the passed thread has executed and the passed function has returned some value.

Since threds in LWT are cooperative, theres no real notion of spawning, starting or stoping such as in POSIX or Java. Asynchronous execution is achieved by binding some work to a thread which will execute later on. This can be
achieved with the `Lwt\_main.yeild' function:
\\
\begin{lstlisting}[frame=single]
val yield : unit -> unit Lwt.t
\end{lstlisting}
\hfill\\
The {\em yield} function returns a thread which simply goes to sleep, then wakes up as soon as possible and terminates. This is entirely useless on it's own but binding to this thread will create a situation where you're able to
schedule something to run in the near future -- without knowing when it will occur.
\\
\\
\section{Investigating OCaml-Java}
\label{sec:investigating_ocaml-java}
%
% Talk about how OCaml-Java achieves concurrency and parallelism (through the concurrency module)
%
Providing the framework to parallel OCaml code in this project, OCaml-Java is a collection of Java programs and libraries that allow you to compile OCaml code to Java bytecode for execution on the JVM; run OCaml bytecode compiled
software on the JVM using an interpreter written in Java; and access Java libraries directly from within OCaml code using a specially designed interface that maps Java classes to OCaml types. However most relevant to this project is
OCaml-Java's ability to run OCaml code in parallel using Java threads.

%
% Talk about how the concurrency module works, examples of code (maybe, or just prose), how it works (wrapper around java libraries)
%
OCaml-Java provides a concurrency module which contains many standard concurrency features such as Locks, atomic variables and condition variables. The locks, for example, can be manipulated as simply as calling `make\_reentrant' to
construct a new lock and `lock' and `unlock' to change acquire/release the lock respectively:
\\
\begin{lstlisting}[frame=single]
val make_reentrant : bool -> t

val lock : t -> unit

val unlock : t -> unit
\end{lstlisting}
\hfill\\
Essentially, the concurrency module is just a set of OCaml wrappers around their Java counterparts\cite{web:clerc2013} therefore the OCaml-Java reentrant lock module `Concurrent.Lock' is a wrapper around the Java reentrant lock class
`java.util.concurrent.locks.ReentrantLock'.
\\
\\
%
% Talk about how OCaml provides neat interface between OCaml and Java with the weird type system (java'lang'system type) etc...
%
For classes that do not yet have an OCaml wrapper, there is a neat interface which allows direct calls to Java functions and manipulation of Java references, for example object instantiation. Via the Java.make and Java.call functions,
you are able to instantiate any Java class or call any Java function:
\\
\begin{lstlisting}[frame=single]
let obj = Java.make "java.lang.Object()"
let itg = Java.make "java.lang.Integer(int)" 123l

let obj_hash = Java.call "java.lang.Object.hashCode():int" obj
let eq = Java.call "java.lang.Object.equals(java.lang.Object):boolean" obj itg
\end{lstlisting}
\hfill\\
The code above gives an example of using the Java.make and Java.call functions. Two Java objects are created named `obj' and `itg' using different classes via the Java.make function, then their hash values are compared to each other
using the Java.call on the hashCode method and the equals method. Whilst the java primitives are easily mapped to OCaml types e.g. a Java int maps directly to an OCaml int32, the types of Java objects need to have their own defining
types within OCaml. The typing scheme introduced makes a java Object map to an OCaml type `'a java\_instance' where `'a' is a Java class. Classes are denoted within OCaml by substituting dots with quotes to abide by the OCaml
syntactic rules\cite{web:clerc2013}, therefore the equivalent OCaml type for `java.lang.Object' would be `java'lang'Object java\_instance'.
\\
\\
\section{Requirements Analysis}
\label{sec:requirements_analysis}
%
% Requirements analysis, what this project has told me about what I need to do/achieve, etc.
%
As a result of my investigations into OCaml, OCaml-Java and LWT, I belive that the interface between multithreaded OCaml-Java and LWT must meet the following requirements:

\begin{description}
\item[Requirement 1]

As discovered in section~\ref{sec:investigating_lwt} OCaml threads and Java threads behave very differently, especially in terms of thread creation overheads. Therefore it is neccessary to create a mapping from LWT threads to Java
threads using a scheduler to perform the mapping operations.

\item[Requirement 2]
??

\item[Requirement 3]
??
\end{description}

\section{Choice of Tools}
\label{sec:choice_of_tools}
%
% Choice of tools, in this case it is Vim, decided against using Object system of OCaml since LWT doesn't use it at all anyway (stuck to modular for consistency)
% used git for version control and github for code host and backup, also set up a mirror on my PWF facilities. Used dropbox for backup and ease of access
% software engineering techniques involved weekly meetings with supervisors about my progress and my best next step. Working by myself so not neccessary to follow protocols such as Agile Development, but generally had `project days'
% where I would spend the whole day (or two) solely on project work (meaning there was less start-stop overhead from doing bits every day).
%
My project depends entirely on the use of OCaml and Java therefore there is no real decision relating to the programming languages I will use. Furthermore LWT and OCaml-Java are two libraries that I will be depending on throughout the
development of the project. These invariants aside, the following section outlines my choice of development environment, including version control, backup precautions taken/software used and the development and build methods applied.

\subsection{Development Environment}
\label{subsec:development_environment}

\subsubsection{Software and Systems}
Unlike Java, OCaml has little in the way of a fully supported IDE. There are addons for IDE's such as Eclipse\footnote{https://www.eclipse.org} which add syntax highlighting and build functions, however most (including my supervisors)
version something\todo{find pwf facilities version}.

\subsubsection{Version Control}
For version control I used Git since I'm already familiar with it and it has always provided me with the neccessary tools I need to work effectively. I also used Github to host my code in the cloud for a few reasons:

\begin{itemize}
\item Github provides educational users with free private repositories which I used for this project.
\item Storing my code on the cloud means that I can easily access it from anywhere with internet access, with all my revisions.
\item My supervisors are also on Github meaning they are easily able to check my progress.
\item Github's interface is appealing to use \todo{remove this}
\end{itemize}

\subsubsection{Backup}
In conjunction with Github as my primary backup solution, I also hosted my code on Dropbox in the case I loose work I haven't yet committed. Furthermore I also have mirrors of my Git repository hosted on the PWF facilities which were pushed to
frequently.

\section{Summary}
%
% Summary (pretty much a mirror of the introduction to the chapter, tell you what I've just told you)
%
Within this chapter I have demonstrated the process of planning and investigation taken in order to prepare for the projects implementation. I have investigated the ways that OCaml and LWT are able to perform asynchronous code
execution, including the cause for OCaml's limitations in fully parallel code compilation and the differences between LWT and Java's handling of threads. Furthermore I have demonstrated a few tools that OCaml-Java has introduced which
allow parallel OCaml code to be written and run on the JVM. Using this information I constructed a set of requirements that I believe are neccessary for this project to adhere to in order to achieve the success criteria. Finally I
explained that Vim will be my choice of IDE, running on Mac OSX; Git and Github will be used for version control and in addition the PWF facilities and Dropbox will be used for backup.

\chapter{Implementation}
\label{chap:implementation}
% what did I even do/core parts of the implementation of project:
% benchmarks, including fib, mergesort.
% making LWT functions thread safe (includes attaching locks to threads, ensuring half-baked threads never see the surface)
% Many implementation problems:
%   LWT is a large software solution, incredibly complex and very popular.
%   OCaml-Java is a mature peice of software, never-the-less still has its fair share of bugs.
%   Initially started to try and get LWT to compile (in its entireity) with OCaml-Java, this involved extracting all the build commands from the makefile (via bash -x dump) and manually editing lines with sed & awk to convert it into
%   a format that OCaml-Java could understand (using ocamljava binaries, libraries, manually preprocessing code, etc).
%   OCaml relies heavily on topfind, a software which automatically constructs ocaml compile commands, including all the relevant libraries. Had to remove all the topfind commands and replace them with their generated output,
%   replacing all libraries with the OCaml-Java counterpart.
%   LWT uses a lot of syntactic sugar which is constructed with Camlp4, the OCaml preprocessor. Unfortunately this is currently broken in OCaml-Java, but fortuntely since it's just a preprocessor I managed to manually preprocess the
%   files and replace them inside the code directory (with a little difficulty since Camlp4 reverts to bytecode when the output is redirected to a file, which meant a lot of struggle wondering why the code was being preprocessed to
%   garbage, furthermore the Camlp4 processing is laced throughout the build commands which meant removing all the p4 switches manually)
%   Came accross many bugs in the OCaml-Java during this process:
%       When compiling OCaml code using ocamlc provided by OCaml-Java, the `shebang' isn't included in the bytecode (unlike vanilla OCaml) therefore you cannot execute it with `./', you must execute it with `ocamlrun'. Caused a lot of
%       pain when trying to figure out why the executeables were not executing.
%       Camlp4 is broken for OCaml-Java 2.0 version 7 and greater. Returns error 'unable to determine class for symbol Camlp4'
%   Managed to get a lot compiling with OCaml-Java, replaced all the C/C++ external calls with exceptions so that I could catch what I needed to implement first to get some kind of result.
%   After getting somewhere close to a compiling LWT, moved onto getting asynchronous I/O working.
%       The greatest difficulty was determining whether a file descriptor in OCaml is the same as a file descriptor in Java and in Unix. The ultimate answer was yes, however Java gives you no access whatsoever to file descriptors of
%       any kind. This means passing file descriptors is either not going to work at all or going to work with a lot of hacking around with Java reflection and JNI.
%   All the problems resulted me having to abandon this section of the project and move onto the parallelism section.

%   refer to thread queuing operation of LWT from preparation section
%   My job was to turn this thread queueing idea into a thread-safe implementation:
%       Started out with creating a worker thread function which will take threads off the thread queue and execute them
%       Whenever Lwt_main.run is called, the worker threads are spawned and continuously process threads on the thread queue until interrupted
%       There is a clear race condition from all worker threads accessing the thread queue simultaneously. To prevent bugs from this, the simple method is to apply a global lock to accessing and processing a thread on the thread
%       queue, keeping parallelism but removing benefits of parallelism (and only introducing overheads).
%       To move away from the global lock, I introduced a single lock around the thread queue which allowed sequential access to the thread list. The lock is released as soon as a thread is removed from the thread queue.
%       The way LWT is written means that threads are incomplete when they're placed onto the yield queue, meaning that a thread may begin executing an incomplete thread.
%       Solution to this problem was to associate a lock with each thread so that only one worker thread may be accessing a thread at a time.
%       When a thread is constructed it is locked initially since it may be incomplete. This is always true for a yield thread since all it does is sleep and re-awaken (which is useless without some waiters hanging on it).
%       Once some waiters have been bound to this yeild thread, a callback is run to unlock the thread, allowing a worker thread to now pick it up and begin execution on it.
%       LWT uses a lot of unusual OCaml code for instance the %identity function which allows explicit type casting from any two types.
%           Clearly defeats the point of type safety in OCaml. It is used to destinguish between a thread type `t', wakener type `u' and a thread_repr type.
%           Thread_repr type may be a chain of thread_repr's with the actual thread type at the bottom of the chain - with pointers to any section of the thread.
%           This whole thing is considered one thread and so each level of the chain must share the lock. Furthermore the colapsing function `repr' must manage lock movement correctly.
%   Normal OCaml code uses camlprof to run profiling on OCaml code, however this is not available in OCaml-Java. Meant I needed to write a Profiling module for the benchmarking process.
%   How profiling works:
%       Create a timer object and run Timer.start at the beginning of a function and Timer.stop at the end of a function.
%       Timing results in nanoseconds can be retrieved from Timer.get_nanos, or millis with Timer.get_millis, etc.
%       Simple and fast so as to get an accurate timing between function invocation and return.
%       No other advanced functions neccessary to complete profiling successfully
% laced lwt with locks
% created a small worker thread function which pops off threads from the queue and executes them
% problems occurred because LWT was written in such a way which allthough concurrent, assumes single threaded (and rightfully so, I mean it is OCaml of course)
% this means thread creation is done in parts and a `half-baked' thread can be put on the 

%
% chapter overview, what will I say in this chapter
% talk about requirements you gave in preparation chapter
%

\section{Parallelism Overview}
%
% Describe how LWT uses thread queue to produce asynchronous requests  
%

%
% Describe how this was translated to run things in parallel with worker threads
%

\section{Thread Safety}
%
% Discuss race condition at taking threads off thread queue, easy fix by adding lock around the queue
%

%
% Discuss race condition at `half-baked' threads being taken off the thread queue (lwt_main.yielded puts it straight on the queue with no waiters, thread run empty, waiters added at end of thread run, thread is garbage collected)
%

%
% Talk about how this was overcome using bind callback
%

%
% 
%
\section{Backing out of I/O}

%
% Describe that attempts were made in Michaelmas/Christmas break on attempting to get entireity of LWT Working
%

%
% Attempt to get LWT to compile and add unimplemented LWT methods afterwards. Came accross a lot of problems...
% A lot of LWT relies on external software which would need to be stripped away or also converted. Tried to get away from build system by dumping all build commands to a build script, then editing manually (using sed, perl)
% Discuss difficulties with using sed on file containing very subtley different commands.
%

%
% Tried to get away from OCamlfind by replacing OCamlfind binaries with a `proxy' binary which takes OCamlfind commands and spits out the OCaml command result.
%

%
% LWT relies heavily on Camlp4. Camlp4 is broken in OCaml-Java and it was a while before I realised it wasn't an error on my part causing difficulties. Managed to use original CamlP4 instead.
%

%
% Managed to strip away all external C/C++ calls and replace then with exceptions so that I could develop the exceptions out one by one
%

%
% Attempting to perform IO between OCaml and Java mean't sharing file descriptors between the representations between the two languages. Unfortunately Java doesn't allow you to tinker with file descriptors at all. Would need to
% perform reflection of sorts to get it working
%

%
% Not much in the way of Documentation for the OCaml-Java -- Java interface, so had to go with a small example provided to my by Xavier Clerc himself.
%

%
% Ultimately time was running short so I had to move on to the actual parallelism by stripping down LWT to it's asynchronous core -- minus any I/O.
%

%
% Learned a lot about taking on a large project. Shouldn't dive straight in, etc...
%

\section{Profiling}
%
% In order to benchmark the speedup gained from parallel OCaml code, I wrote some benchmarks in three different ways: normal OCaml, singlethreaded LWT, parallel/asynchronous LWT.
%

%
% Wrote fibonacci benchmark (give example code, and talk about how it would run in the system)
%

%
% Wrote mergesort benchmark (again, example code and how it would run in the system)
%


\chapter{Evaluation}
\label{chap:evaluation}
% Talk about what success critera you've met, and why if any have not been met.
% completed all my success criteria:
%   Able to show scalability difference between 3 versions of benchmarks
%       Need to write/find some program which runs under my software and demonstrates the differences
%   Parallel benchmarks show scalability of LWT running with multithreaded code
%       Clear from the results of the Mergesort graph
% talk how testing was achieved: On my mac, 2 cores 4 hw threads, desktop - similar, roo - 48 core machine.
% implemented fib and merge sort (based on cilk) for parallel benchmarks. Versions written in normal OCaml, LWT and asynchronous LWT to compare the differences between them.
% Graphed number of threads against each other to show speed up
% speed up calculations and other theories e.g. ahmdals law, etc.
% graphed singlethreaded to multithreaded to show scalability
% fib did particularly bad because all it does is expose the overheads of parallelism (one addition per thread, however theres a ton of thread creation and processing behind each one).
% mergesort did much better as when it gets down to 1000 values, the threads are running parallel sorts on 1000 values between 48 cores, which is really fast.
% NEED TO EXPAND ON EVALUATION MORE, THERES LOADS OF GRAPHS I CAN MAKE

\chapter{Conclusions}
\label{chap:conclusions}
% Talk about what I wanted to do with the private public threads, how that would've overcome the `half-baked' threads problem and allowed me to construct a workstealer. The contention on the single thread queue could've been
% aleviated.
% talk about how I took on a massive project but should've broken it down to make it easier on myself.

\chapter{Bibliography}
\label{chap:bibliography}
\bibliography{resources}

\chapter{Appendices}
\label{chap:appendices}

\chapter{Project Proposal}
\label{chap:proposal}
\input{probody}

\end{document}
