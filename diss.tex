% The master copy of this demo dissertation is held on Dr. Martin Richards filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last Updated by Dorian Peake in 2014

\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{todonotes}
\usepackage{pgf}                        % for my todo notes
\usepackage{cite}
%\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Dorian Peake}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Parallelism in OCaml Under the JVM} \\
\vspace*{5mm}
Computer Science Tripos \\
\vspace*{5mm}
St John's College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Dorian Peake  \\
College:            & \bf St John's College                     \\
Project Title:      & \bf Parallelism under OCaml using the JVM  \\
Examination:        & \bf Computer Science Tripos, July 2014        \\
Word Count:         & \bf TBC  \\
Project Originator: & Dorian Peake                    \\
Supervisor:         & Jeremy Yallop                   \\ 
\end{tabular}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The aim of this project was to highlight the differences between single and multithreaded OCaml code. This was done by adapting the Lightweight Threading Library (LWT) -- a very popular threading library for OCaml -- to use the OCaml
to Java bytecode compiler OCaml-Java, thus allowing software written with LWT to utilise the multithreading capabilities of the JVM. \todo{fill this out a bit more, maybe talk about what differences the project was looking for/found}

\section*{Work Completed}
{\bf Pinkbook says at most 100 words summarising work completed, e.g. scheduler of LWT to OCaml-Java threads, worker public/private queue structure, benchmarks, etc.}
The LWT threading capabilities have been integrated with OCaml-Java, thus allowing some LWT programs to compile to Java bytecode and run simultaneously on the JVM. This is done using a scheduler algorithm which maps LWT threads to
Java threads. \todo{fill this out some more as well when possible}

\section*{Special Difficulties}
{\bf Pinkbook says at most 100 words describing special difficulties, but most should just say "None" }
None, {\em possibly}.

\newpage
\section*{Declaration}

I, Dorian Peake of St John's College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}
\todo{add thanks at the end}
This document owes much to an earlier version written by Simon Moore
.  His help, encouragement and advice was greatly 
appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}
\label{chap:Introduction}
\section{Motivation}
\label{sec:motivation}
% What I want to say:
% Talk about how things are moving/have moved from uniprocessor to multiprocessor systems and parallelism. Important to write programs that will run well on the hardware of the day (which means writing programs which exploit
% prarallelism well) and hopefelly will scale easily to hardware of tomorrow.
% Talk about functional programming, what it is, where it came from and why it's good/cool. Examples of C++11 and Java incoroperating functional paradigms, more and more programmers using functional paradigms for type safety(due to
% static typing) efficiency (due to expressiveness of code, first class functions, etc) and abstraction from the complexity of the hardware. Programs written with ML  cannot crash. Mention map-reduce and maybe some other notable
% examlles..
% Security in the mathematics of how it works.
% Talk (more) on OCaml, how it is a 'very good' functional programming language: based on ML, has all the wonderful things I've mentioned about funcitonal programming implemented in the language, incorperates OOP and imerative when
% neccessary but doesn't allow parallelism due to core runtime and non-concurrent garbage collector.
% Enter OCaml-Java, OCaml to java compiler which allows OCaml code to run on the JVM. Also ultimately means that the compiled code can use multiple java threads - now we have truly parallel OCaml code.
% Although OCaml is singlethreaded at the lowest level, there exist threading libraries to perform asynchronous tasks within OCaml, for example Async (developed by Jane Street \citeme} and LWT, produced by Ocsigen). These libraries
% provide a great interface for multithreading in OCaml but lack the underlying support from the OCaml language - It would be interesting to find out just what the benefits and drawbacks exist from executing OCaml asynchrnous code in
% a multithreaded environment (thus the motivation of the project, we can achieve some sort of comparisson between multithreaded and singlethreaded OCaml using OCaml-Java as our vector into multithreaded OCaml code -- Just a matter
% getting one of the asynchronous libraries to work with OCaml-Java.
% How much better is multithreaded OCaml code over singlethreaded code? What are the challenges/benefits of writing multithreaded programs using a functional programming language? How well do threaded/asynchronous OCaml programs
% translate onto a multithreaded system? It would be interesting to test all these things. (possibly only talk about `I wanted to test the difference between using threaded
%
%
% Talk about why multithreading is important
%
\todo{this para is sounds like a history talk which is what thingybob told us not to do}
Trends current trends in chip advancement have shown that since around 2003\cite{hennessy2012}, the growth in processor frequency has effectively plateaued and computer architects have had to look for different methods of achieving
greater computational power. The diminishing returns of processor frequency have been greatly effected by the amount of energy required to switch a transistor's output -- known as the {\em dynamic energy}. This dynamic energy needs to
be dissapated through the side of the chip die at a size of around 1.5cm. Clearly this becomes an increasingly difficult task for processors with greater clock frequencies which generate more heat energy to dissipate. As a result of
this and some other unmentioned factors, the focus of achieving greater performance has moved from clock frequency improvements to parallel processing. Therefore it is important for software developers to create software that is
able to take full advantage of the hardware of today and estimate ways to make it scale on the hardware of tomorrow.
\\
\\
%
% Talk about why functional programming is important
%
Functional Programming concepts have been around since Turing and Church's work in the 1930's\cite{scott2009} but have become more popular in recent times. The expressiveness that functional programming paradigms give the programmer
has finally caught on in mainstream development and as such languages such as C++ and Java are incorperating notable functional programming techniques such as type inference\cite{web:autokeyword} and first-class anonymous functions
(lambas)\cite{web:javalambda}. Notable functional languages include Haskell and ML which have inspired more widely used functional languages such as OCaml\cite{madhavapeddy2013}. OCaml is a very extensive functional language which
also includes an elegant object system, thus incorperating the best of both functional and imperative programming techniques and making it a very powerful language to develop with. Unfortunately OCaml in it's current vanilla state is
unable to compile parallel code, which is becoming an ever more neccessary approach to development as systems become more and more parallel.
\\
\\
%
% Talk about how java has multithreading but no functional, whereas OCaml is functional with no multithreading
%
Java on the other hand is a very good imperative programming language/system. It compiles to bytecode which runs on it's virtual machine which is implemented in everything from ATM's and credit card Chips\todo{cite where it says ATM's
and credit card chips use Java} to home desktops and servers -- leading to one of the slogan's \todo{find where this slogan is written} `{\em write once, run everywhere}'. Over the years the JVM has become highly optimised to the
hardware/systems that it runs on such that there is little diffrence between Java code running on the JVM and natively compiled code. Furthermore, Java supports parallel processing, fully utilising any number of cores/hardware threads
that the system has to offer.
\\
\\
%
% Talk about how OCaml-Java merges the two but is in need of a sufficient threading library, many exist (LWT, Async) but are not yet compatible. This is where my project comes in.
%
A peice of software called OCaml-Java aims to merge best aspects of both languages together to create a better OCaml programming solution. It achieves this by compiling OCaml code to Java bytecode, thus allowing it to run on any JVM.
This means two things:
\begin{itemize}
\item OCaml can now be written to run on a wide variety of hardware/systems.
\item OCaml can use Java's multithreading capabilities to run fully parallel OCaml code\cite{clerc2012}
\end{itemize}
OCaml-Java comes with a basic collection of concurrency tools which are essentially a small subset of Java's own concurrency library, with wrappers which allows access to them from within OCaml. Clearly the concurrency techniques
provided by Java do not nicely translate to the way concurrency is done in a functional programming language like OCaml. There already exist extremely good and highly optimised OCaml concurrency libraries such as Async by Jane Street
and LWT (Lightweight Threads Library) by Ocsigen, however these will not directly work with OCaml-Java when compiled to Java bytecode. Somehow getting one of these OCaml concurrency libraries working with OCaml-Java would demonstrate
OCaml-Java's true potential for parallel OCaml code, written in the functional flavour that works best with the OCaml language -- this is the motivation for my project.
\\
\\
%
% Briefly outline project, and where I this dissertation will take the reader on their journey
%
My project aims to interface OCaml-Java and the LWT concurrency library in order to demonstrate OCaml-Java's potential for parallelised OCaml code. The rest of this document outlines the preparation and research I conducted in order
to plan my approach to this project in chapter~\ref{chap:preparation}; the methods and processes that were used to implement the project in chapter~\ref{chap:implementation} and the result of the project development and the work
process as a whole in chapter~\ref{chap:evaluation}. My code can also be found in chapter~\ref{chap:appendices}.
\\
\\
%
% Cant think of any related work off the top of my head... Might delete this little section
%
\section{Related Work}
\label{sec:related_work}


% \todo{I don't like the jump between these two paragraphs, seems illogical but they're connected later on}
% Part of the way Programming languages are advancing is towards Functional Programming. Functional Programming concepts have been around since Turing, Church's and Kleene's independent work in the 1930's\cite{scott2009} and
% fundamentally defines the output of a program as the mathematical funcion of its inputs. This is different from imperative languages in that the functions defined in a (purely) functional language have no state and therefore have no
% side effects. If you were to provide the same inputs to the same function you would always get the same output. Another important aspect of functional languages is the idea of functions being first-class values and higher-order
% functions. First-class value functions are functions that are able to be passed as an argument to another function. The function receiving the first-class function argument is known as a higher-order function (which may also return a
% function as a result). Considering these new weapons for development we have obtained from functional programming languages, the expressiveness of our programs has already become incredibly vast. \todo{Might add map function as
% example of higher-order function}.
% Functions such as map, reduce and fold ere very easily expressed using higher-order functions. Java achieves something similar to a higher-order function when using Java Collections, for example Java.util.TreeSet. This class can be
% constructed by passing an object implementing the Comparator interface. This interface contains only one function `compareTo' which creates an ordering between any two elements of a class. Essentially, java is wrapping a class around
% this compareTo function so that it may be passed similarly to a higher-order function. In C you can also pass functions via a function pointer implememnts some aspects of higher-order functions. However bothe Java and C++ are picking
% up many more functional programming paradigms in the latest versions of their languages: Java 8 and C++11\cite{web:javalambda}\cite{web:autokeyword}. Functional programming paradigms are more efficient, with examples such as
% higher-order functions, and safer; many functional languages are almost entirely statically typed which means \todo{no runtime errors, but I'm not sure if thats entirely due to static typing}no runtime errors due to type conflicts and
% faster code (since types do not need to be checked at runtime). The functional programming language ML has become increasingly popular in research institutes and is a great example of a good functional programming
% language. As an example of saftey in functional programming, compiled ML code cannot crash\cite{paulson1996}.


\chapter{Preparation}
\label{chap:preparation}
% Researched into why OCaml cannot fundmentally produce multithreaded code.
% The OCaml-Java paper has a nice section on the reasons that OCaml is not a multithread capable language: Garbage collector is neither parallel nor concurrent and core libraries are not reentrant.
% Ultimately the core libraries can be made reentrant, however sorting out the garbage collector is a more difficult and involved task.
% OCaml does provide a threads library but manual states the threads library is implemented by time sharing on single processor {cite ocaml manual}. 
% Researched into ways of doing concurrent processing in OCaml.
% in conjunction with the OCaml threads library, there are also other threading libraries with a richer feature set, expanding on the OCaml threads library, such as LWT, ASync.
% ultimately the as to which one was solely based on the fact that LWT is more popular, (as I have never worked with either and wouldn't have time to test both of them out and decide which I would like to work with the most).
% Projects exist (such as those given in OCaml-Java paper) on multicore implementations of ocaml
% Research into LWT
% Lwt is an extensive concurrency suite for OCaml which uses lightweight threads that are created and destroyed very quickly.
% almost all expressions used within LWT results in a thread being created, which returns the answer.
% clearly Java threads and LWT
% Research into OCaml-Java
% Ocaml-Java provides a `Concurrent' module which provides a few core concurrency solutions e.g. locks, condition variables, atomic variables, etc.
% Also provides a threadign library which allows the creation of Java threads to run bytecode compiled OCaml functions.
% all accessible via OCaml therefore little/no Java will/was needed to link this with LWT. Need to essentially map the functions which are executed in OCaml threads to java threads.
% LWT Threads are lightweight and inexpensive to create/destroy, Java threads are expensive to create/destroy therefore won't be good enough to map each LWT thread to each Java thread.
% Leads to requirements: Maximum java thread lifetime (for efficiency, else parallelism could be drowned out by overheads), and some others...
% Tools used:
% The development of this project relies on the OCaml language, LWT and OCaml-Java
% Used github for backup and version control
% also stored code on dropbox for backup purposes and ease of access

%
% Outline of what is to come in this chapter
%
\section{Investigating Multithreaded OCaml}
\label{sec:investigating_multithreaded_ocaml}
%
% Talk about what makes it impossible to run parallel OCaml code and why OCaml-Java can
%
In order to outline the best implementation plan for the LWT--OCaml-Java interface, it was neccessary to understand the limitations that OCaml possessed in compiling parallel code. The OCaml-Java paper from the 2012 `Trends in
Functional Programming' collection\cite{clerc2012} gives rise to the reason -- stating that the Core OCaml library is not reentant and the OCaml garbage collector is neither parallel nor concurrent. Making the Core library reentrant
is a relatively straight forward change to the system, however making the garbage collector parallel is not as simple. Ultimately there are many ways to perform concurrent and parallel garbage collection, however this has proven to be
`too complex' for the current state of the OCaml system\todo{cite this, definitely saw this somewhere}. Java's G1 is fully parallel/todo{cite me} and allows multithreaded support of Java applications, therefore by compiling OCaml code
do java bytecode, the language may utilise Java's parallelism capabilities.
\\
\\
%
% Talk about ways of doing concurrent processing in OCaml
%
It was neccessary to decide which of the popular concurrency libraries available to OCaml I should use for the purposes of this project therefore I researched into OCaml's ability to produce concurrent OCaml code. Despite OCaml's
inability to perform parallel code, OCaml provides a threads library for running concurrent OCaml code. The OCaml manual\cite{leroy2013} describes the OCaml threads as being concurrently on a single processor using
time sharing. However there exist other concurrency libraries which boast a richer feature set than the one provided by OCaml as default. Examples of these languages are Async -- developed by Jane Street Capital\todo{cite me} -- and LWT
(Lightweight threads library) -- developed by Ocsigen\todo{cite me also}. These are the two main concurrency packages used within OCaml development, choosing one to use within my project was simply a matter of popularity, my reasoning is that they are
both extremely good packages and would serve well to demonstrate the capabilities of multithreaded OCaml-Java.
\\
\\
%
% Research into LWT, how it works and how it should work in relation to OCaml-Java (i.e. scheduling LWT threads since they're teenie weenie)
%
\section{Investigating LWT}
\label{sec:investigating_lwt}
LWT is an extensive concurrency suite for OCaml which is based around the idea of lightweight cooperative threads\cite{dimino2012}. The threads

\chapter{Implementation}
\label{chap:implementation}
% what did I even do/core parts of the implementation of project:
% benchmarks, including fib, mergesort.
% makeing LWT functions thread safe (includes attaching locks to threads, ensuring half-baked threads never see the surface)
% Many implementation problems:
%   LWT is a large software solution, incredibly complex and very popular.
%   OCaml-Java is a mature peice of software, never-the-less still has its fair share of bugs.
%   Initially started to try and get LWT to compile (in its entireity) with OCaml-Java, this involved extracting all the build commands from the makefile (via bash -x dump) and manually editing lines with sed & awk to convert it into
%   a format that OCaml-Java could understand (using ocamljava binaries, libraries, manually preprocessing code, etc).
%   OCaml relies heavily on topfind, a software which automatically constructs ocaml compile commands, including all the relevant libraries. Had to remove all the topfind commands and replace them with their generated output,
%   replacing all libraries with the OCaml-Java counterpart.
%   LWT uses a lot of syntactic sugar which is constructed with Camlp4, the OCaml preprocessor. Unfortunately this is currently broken in OCaml-Java, but fortuntely since it's just a preprocessor I managed to manually preprocess the
%   files and replace them inside the code directory (with a little difficulty since Camlp4 reverts to bytecode when the output is redirected to a file, which meant a lot of struggle wondering why the code was being preprocessed to
%   garbage, furthermore the Camlp4 processing is laced throughout the build commands which meant removing all the p4 switches manually)
%   Came accross many bugs in the OCaml-Java during this process:
%       When compiling OCaml code using ocamlc provided by OCaml-Java, the `shebang' isn't included in the bytecode (unlike vanilla OCaml) therefore you cannot execute it with `./', you must execute it with `ocamlrun'. Caused a lot of
%       pain when trying to figure out why the executeables were not executing.
%       Camlp4 is broken for OCaml-Java 2.0 version 7 and greater. Returns error 'unable to determine class for symbol Camlp4'
%   Managed to get a lot compiling with OCaml-Java, replaced all the C/C++ external calls with exceptions so that I could catch what I needed to implement first to get some kind of result.
%   After getting somewhere close to a compiling LWT, moved onto getting asynchronous I/O working.
%       The greatest difficulty was determining whether a file descriptor in OCaml is the same as a file descriptor in Java and in Unix. The ultimate answer was yes, however Java gives you no access whatsoever to file descriptors of
%       any kind. This means passing file descriptors is either not going to work at all or going to work with a lot of hacking around with Java reflection and JNI.
%   All the problems resulted me having to abandon this section of the project and move onto the parallelism section.
% describe how LWT works:
%   Lwt.Poll repeatedly checks whether a thread has completed, this is used with Lwt_main.run to start a thread off and relay it's completion to the thread that spawned it.
%   As threads are run, more threads are spawned and put onto the end of a thread queue. In single threaded LWT all the threads are executed in FIFO order (drawing time, draw a thread being taken off, spawning more threads onto the
%   back and then executing the next one on the top of the queue)
%   My job was to turn this thread queueing idea into a thread-safe implementation:
%       Started out with creating a worker thread function which will take threads off the thread queue and execute them
%       Whenever Lwt_main.run is called, the worker threads are spawned and continuously process threads on the thread queue until interrupted
%       There is a clear race condition from all worker threads accessing the thread queue simultaneously. To prevent bugs from this, the simple method is to apply a global lock to accessing and processing a thread on the thread
%       queue, keeping parallelism but removing benefits of parallelism (and only introducing overheads).
%       To move away from the global lock, I introduced a single lock around the thread queue which allowed sequential access to the thread list. The lock is released as soon as a thread is removed from the thread queue.
%       The way LWT is written means that threads are incomplete when they're placed onto the yield queue, meaning that a thread may begin executing an incomplete thread.
%       Solution to this problem was to associate a lock with each thread so that only one worker thread may be accessing a thread at a time.
%       When a thread is constructed it is locked initially since it may be incomplete. This is always true for a yield thread since all it does is sleep and re-awaken (which is useless without some waiters hanging on it).
%       Once some waiters have been bound to this yeild thread, a callback is run to unlock the thread, allowing a worker thread to now pick it up and begin execution on it.
%       LWT uses a lot of unusual OCaml code for instance the %identity function which allows explicit type casting from any two types.
%           Clearly defeats the point of type safety in OCaml. It is used to destinguish between a thread type `t', wakener type `u' and a thread_repr type.
%           Thread_repr type may be a chain of thread_repr's with the actual thread type at the bottom of the chain - with pointers to any section of the thread.
%           This whole thing is considered one thread and so each level of the chain must share the lock. Furthermore the colapsing function `repr' must manage lock movement correctly.
%   Normal OCaml code uses camlprof to run profiling on OCaml code, however this is not available in OCaml-Java. Meant I needed to write a Profiling module for the benchmarking process.
%   How profiling works:
%       Create a timer object and run Timer.start at the beginning of a function and Timer.stop at the end of a function.
%       Timing results in nanoseconds can be retrieved from Timer.get_nanos, or millis with Timer.get_millis, etc.
%       Simple and fast so as to get an accurate timing between function invocation and return.
%       No other advanced functions neccessary to complete profiling successfully
% laced lwt with locks
% created a small worker thread function which pops off threads from the queue and executes them
% problems occurred because LWT was written in such a way which allthough concurrent, assumes single threaded (and rightfully so, I mean it is OCaml of course)
% this means thread creation is done in parts and a `half-baked' thread can be put on the 


\chapter{Evaluation}
\label{chap:evaluation}
% Talk about what success critera you've met, and why if any have not been met.
% completed all my success criteria:
%   Able to show scalability difference between 3 versions of benchmarks
%       Need to write/find some program which runs under my software and demonstrates the differences
%   Parallel benchmarks show scalability of LWT running with multithreaded code
%       Clear from the results of the Mergesort graph
% talk how testing was achieved: On my mac, 2 cores 4 hw threads, desktop - similar, roo - 48 core machine.
% implemented fib and merge sort (based on cilk) for parallel benchmarks. Versions written in normal OCaml, LWT and asynchronous LWT to compare the differences between them.
% Graphed number of threads against each other to show speed up
% speed up calculations and other theories e.g. ahmdals law, etc.
% graphed singlethreaded to multithreaded to show scalability
% fib did particularly bad because all it does is expose the overheads of parallelism (one addition per thread, however theres a ton of thread creation and processing behind each one).
% mergesort did much better as when it gets down to 1000 values, the threads are running parallel sorts on 1000 values between 48 cores, which is really fast.
% NEED TO EXPAND ON EVALUATION MORE, THERES LOADS OF GRAPHS I CAN MAKE

\chapter{Conclusions}
\label{chap:conclusions}
% Talk about what I wanted to do with the private public threads, how that would've overcome the `half-baked' threads problem and allowed me to construct a workstealer. The contention on the single thread queue could've been
% aleviated.
% talk about how I took on a massive project but should've broken it down to make it easier on myself.

\chapter{Bibliography}
\label{chap:bibliography}
\bibliography{resources}

\chapter{Appendices}
\label{chap:appendices}

\chapter{Project Proposal}
\label{chap:proposal}
\input{probody}

\end{document}
