% The master copy of this demo dissertation is held on Dr. Martin Richards filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last Updated by Dorian Peake in 2014

\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{todonotes}
\usepackage{pgf}                        % for my todo notes
\usepackage{cite}
%\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Dorian Peake}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Parallelism in OCaml Under the JVM} \\
\vspace*{5mm}
Computer Science Tripos \\
\vspace*{5mm}
St John's College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Dorian Peake  \\
College:            & \bf St John's College                     \\
Project Title:      & \bf Parallelism under OCaml using the JVM  \\
Examination:        & \bf Computer Science Tripos, July 2014        \\
Word Count:         & \bf TBC  \\
Project Originator: & Dorian Peake                    \\
Supervisor:         & Jeremy Yallop                   \\ 
\end{tabular}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The aim of this project was to highlight the differences between single and multithreaded OCaml code. This was done by adapting the Lightweight Threading Library (LWT) -- a very popular threading library for OCaml -- to use the OCaml
to Java bytecode compiler OCaml-Java, thus allowing software written with LWT to utilise the multithreading capabilities of the JVM. \todo{fill this out a bit more, maybe talk about what differences the project was looking for/found}

\section*{Work Completed}
{\bf Pinkbook says at most 100 words summarising work completed, e.g. scheduler of LWT to OCaml-Java threads, worker public/private queue structure, benchmarks, etc.}
The LWT threading capabilities have been integrated with OCaml-Java, thus allowing some LWT programs to compile to Java bytecode and run simultaneously on the JVM. This is done using a scheduler algorithm which maps LWT threads to
Java threads. \todo{fill this out some more as well when possible}

\section*{Special Difficulties}
{\bf Pinkbook says at most 100 words describing special difficulties, but most should just say "None" }
None, {\em possibly}.

\newpage
\section*{Declaration}

I, Dorian Peake of St John's College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}
\todo{add thanks at the end}
This document owes much to an earlier version written by Simon Moore
.  His help, encouragement and advice was greatly 
appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}
\section{Motivation}
% What I want to say:
% Talk about how things are moving/have moved from uniprocessor to multiprocessor systems and parallelism. Important to write programs that will run well on the hardware of the day (which means writing programs which exploit
% prarallelism well) and hopefelly will scale easily to hardware of tomorrow.
% Talk about functional programming, what it is, where it came from and why it's good/cool. Examples of C++11 and Java incoroperating functional paradigms, more and more programmers using functional paradigms for type safety(due to
% static typing) efficiency (due to expressiveness of code, first class functions, etc) and abstraction from the complexity of the hardware. Programs written with ML  cannot crash. Mention map-reduce and maybe some other notable
% examlles..
% Security in the mathematics of how it works.
% Talk (more) on OCaml, how it is a 'very good' functional programming language: based on ML, has all the wonderful things I've mentioned about funcitonal programming implemented in the language, incorperates OOP and imerative when
% neccessary but doesn't allow parallelism due to core runtime and non-concurrent garbage collector.
% Enter OCaml-Java, OCaml to java compiler which allows OCaml code to run on the JVM. Also ultimately means that the compiled code can use multiple java threads - now we have truly parallel OCaml code.
% Although OCaml is singlethreaded at the lowest level, there exist threading libraries to perform asynchronous tasks within OCaml, for example Async (developed by Jane Street \citeme} and LWT, produced by Ocsigen). These libraries
% provide a great interface for multithreading in OCaml but lack the underlying support from the OCaml language - It would be interesting to find out just what the benefits and drawbacks exist from executing OCaml asynchrnous code in
% a multithreaded environment (thus the motivation of the project, we can achieve some sort of comparisson between multithreaded and singlethreaded OCaml using OCaml-Java as our vector into multithreaded OCaml code -- Just a matter
% getting one of the asynchronous libraries to work with OCaml-Java.
% How much better is multithreaded OCaml code over singlethreaded code? What are the challenges/benefits of writing multithreaded programs using a functional programming language? How well do threaded/asynchronous OCaml programs
% translate onto a multithreaded system? It would be interesting to test all these things. (possibly only talk about `I wanted to test the difference between using threaded
\todo{this para is sounds like a history talk which is what thingybob told us not to do}
Trends current trends in chip advancement have shown that since around 2003\cite{hennessy2012}, the growth in processor frequency has effectively plateaued and computer architects have had to look for different methods of achieving
greater computational power. The diminishing returns of processor frequency have been greatly effected by the amount of energy required to switch a transistor's output -- known as the {\em dynamic energy}. This dynamic energy needs to
be dissapated through the side of the chip die at a size of around 1.5cm. Clearly this becomes an increasingly difficult task for processors with greater clock frequencies which create more energy to dissipate. As a result of this and
some other unmentioned factors, the focus of achieving greater performance has moved from clock frequency improvements to parallel processing. As a result, it is important for software developers to create software that is able to
take full advantage of the hardware of today and estimate on how to make it last on the hardware of tomorrow.

\todo{I don't like the jump between these two paragraphs, seems illogical but they're connected later on}
Functional Programming concepts have been around for
\chapter{Preparation}
% Researched into why OCaml cannot fundmentally produce multithreaded code.
% The OCaml-Java paper has a nice section on the reasons that OCaml is not a multithread capable language: Garbage collector is neither parallel nor concurrent and core libraries are not reentrant.
% Ultimately the core libraries can be made reentrant, however sorting out the garbage collector is a more difficult and involved task.
% OCaml does provide a threads library but manual states the threads library is implemented by time sharing on single processor {cite ocaml manual}. 
% Researched into ways of doing concurrent processing in OCaml.
% in conjunction with the OCaml threads library, there are also other threading libraries with a richer feature set, expanding on the OCaml threads library, such as LWT, ASync.
% ultimately the as to which one was solely based on the fact that LWT is more popular, (as I have never worked with either and wouldn't have time to test both of them out and decide which I would like to work with the most).
% Projects exist (such as those given in OCaml-Java paper) on multicore implementations of ocaml
% Research into LWT
% Lwt is an extensive concurrency suite for OCaml which uses lightweight threads that are created and destroyed very quickly.
% almost all expressions used within LWT results in a thread being created, which returns the answer.
% clearly Java threads and LWT
% Research into OCaml-Java
% Ocaml-Java provides a `Concurrent' module which provides a few core concurrency solutions e.g. locks, condition variables, atomic variables, etc.
% Also provides a threadign library which allows the creation of Java threads to run bytecode compiled OCaml functions.
% all accessible via OCaml therefore little/no Java will/was needed to link this with LWT. Need to essentially map the functions which are executed in OCaml threads to java threads.
% LWT Threads are lightweight and inexpensive to create/destroy, Java threads are expensive to create/destroy therefore won't be good enough to map each LWT thread to each Java thread.
% Leads to requirements: Maximum java thread lifetime (for efficiency, else parallelism could be drowned out by overheads), and some others...
% Tools used:
% The development of this project relies on the OCaml language, LWT and OCaml-Java
% Used github for backup and version control
% also stored code on dropbox for backup purposes and ease of access

\chapter{Implementation}
% what did I even do/core parts of the implementation of project:
% benchmarks, including fib, mergesort.
% makeing LWT functions thread safe (includes attaching locks to threads, ensuring half-baked threads never see the surface)
% Many implementation problems:
%   LWT is a large software solution, incredibly complex and very popular.
%   OCaml-Java is a mature peice of software, never-the-less still has its fair share of bugs.
%   Initially started to try and get LWT to compile (in its entireity) with OCaml-Java, this involved extracting all the build commands from the makefile (via bash -x dump) and manually editing lines with sed & awk to convert it into
%   a format that OCaml-Java could understand (using ocamljava binaries, libraries, manually preprocessing code, etc).
%   OCaml relies heavily on topfind, a software which automatically constructs ocaml compile commands, including all the relevant libraries. Had to remove all the topfind commands and replace them with their generated output,
%   replacing all libraries with the OCaml-Java counterpart.
%   LWT uses a lot of syntactic sugar which is constructed with Camlp4, the OCaml preprocessor. Unfortunately this is currently broken in OCaml-Java, but fortuntely since it's just a preprocessor I managed to manually preprocess the
%   files and replace them inside the code directory (with a little difficulty since Camlp4 reverts to bytecode when the output is redirected to a file, which meant a lot of struggle wondering why the code was being preprocessed to
%   garbage, furthermore the Camlp4 processing is laced throughout the build commands which meant removing all the p4 switches manually)
%   Came accross many bugs in the OCaml-Java during this process:
%       When compiling OCaml code using ocamlc provided by OCaml-Java, the `shebang' isn't included in the bytecode (unlike vanilla OCaml) therefore you cannot execute it with `./', you must execute it with `ocamlrun'. Caused a lot of
%       pain when trying to figure out why the executeables were not executing.
%       Camlp4 is broken for OCaml-Java 2.0 version 7 and greater. Returns error 'unable to determine class for symbol Camlp4'
%   Managed to get a lot compiling with OCaml-Java, replaced all the C/C++ external calls with exceptions so that I could catch what I needed to implement first to get some kind of result.
%   After getting somewhere close to a compiling LWT, moved onto getting asynchronous I/O working.
%       The greatest difficulty was determining whether a file descriptor in OCaml is the same as a file descriptor in Java and in Unix. The ultimate answer was yes, however Java gives you no access whatsoever to file descriptors of
%       any kind. This means passing file descriptors is either not going to work at all or going to work with a lot of hacking around with Java reflection and JNI.
%   All the problems resulted me having to abandon this section of the project and move onto the parallelism section.
% describe how LWT works:
%   Lwt.Poll repeatedly checks whether a thread has completed, this is used with Lwt_main.run to start a thread off and relay it's completion to the thread that spawned it.
%   As threads are run, more threads are spawned and put onto the end of a thread queue. In single threaded LWT all the threads are executed in FIFO order (drawing time, draw a thread being taken off, spawning more threads onto the
%   back and then executing the next one on the top of the queue)
%   My job was to turn this thread queueing idea into a thread-safe implementation:
%       Started out with creating a worker thread function which will take threads off the thread queue and execute them
%       Whenever Lwt_main.run is called, the worker threads are spawned and continuously process threads on the thread queue until interrupted
%       There is a clear race condition from all worker threads accessing the thread queue simultaneously. To prevent bugs from this, the simple method is to apply a global lock to accessing and processing a thread on the thread
%       queue, keeping parallelism but removing benefits of parallelism (and only introducing overheads).
%       To move away from the global lock, I introduced a single lock around the thread queue which allowed sequential access to the thread list. The lock is released as soon as a thread is removed from the thread queue.
%       The way LWT is written means that threads are incomplete when they're placed onto the yield queue, meaning that a thread may begin executing an incomplete thread.
%       Solution to this problem was to associate a lock with each thread so that only one worker thread may be accessing a thread at a time.
%       When a thread is constructed it is locked initially since it may be incomplete. This is always true for a yield thread since all it does is sleep and re-awaken (which is useless without some waiters hanging on it).
%       Once some waiters have been bound to this yeild thread, a callback is run to unlock the thread, allowing a worker thread to now pick it up and begin execution on it.

% laced lwt with locks
% created a small worker thread function which pops off threads from the queue and executes them
% problems occurred because LWT was written in such a way which allthough concurrent, assumes single threaded (and rightfully so, I mean it is OCaml of course)
% this means thread creation is done in parts and a `half-baked' thread can be put on the 


\chapter{Evaluation}
% Talk about what success critera you've met, and why if any have not been met.
% talk how testing was achieved: On my mac, 2 cores 4 hw threads, desktop - similar, roo - 48 core machine.
% implemented fib and merge sort (based on cilk) for parallel benchmarks. Versions written in normal OCaml, LWT and asynchronous LWT to compare the differences between them.
% Graphed number of threads against each other to show speed up
% graphed singlethreaded to multithreaded to show scalability
% fib did particularly bad because all it does is expose the overheads of parallelism (one addition per thread, however theres a ton of thread creation and processing behind each one).
% mergesort did much better as when it gets down to 1000 values, the threads are running parallel sorts on 1000 values between 48 cores, which is really fast.
% NEED TO EXPAND ON EVALUATION MORE, THERES LOADS OF GRAPHS I CAN MAKE

\chapter{Conclusions}
% Talk about what I wanted to do with the private public threads, how that would've overcome the `half-baked' threads problem and allowed me to construct a workstealer. The contention on the single thread queue could've been
% aleviated.
% talk about how I took on a massive project but should've broken it down to make it easier on myself.

\chapter{Bibliography}
\bibliography{resources}
\chapter{Appendices}

\chapter{Project Proposal}
\input{probody}
\end{document}
